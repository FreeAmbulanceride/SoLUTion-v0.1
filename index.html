<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>On-Set Color & Composition Studio</title>
<style>
:root{
  --ui-primary:#0B1220;     /* ~60% */
  --ui-secondary:#172036;   /* ~30% */
  --ui-accent:#12D6DF;      /* ~10% */
  --ui-text:#EDEFF2; --ui-text-muted:#B8C2D6;
  --ui-border:rgba(255,255,255,.08); --ui-surface:rgba(255,255,255,.04);
  --ui-ring:rgba(18,214,223,.55);
}
*{box-sizing:border-box}
body{margin:0;background:var(--ui-primary);color:var(--ui-text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
a.btn,button{appearance:none;border:0;border-radius:12px;padding:10px 16px;font-weight:700;background:var(--ui-accent);color:#051A1D;box-shadow:0 2px 10px rgba(0,0,0,.25)}
a.btn:active,button:active{transform:translateY(1px)}
.container{max-width:1100px;margin:0 auto;padding:24px}
.card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
  border:1px solid var(--ui-border); border-radius:16px; padding:24px; box-shadow:0 10px 30px rgba(0,0,0,.25)}
/* Landing */
.hero{padding:64px 0}
h1{margin:0 0 6px;font-size:28px}
.lead{margin:0 0 18px;color:var(--ui-text-muted)}
.actions{display:flex;gap:12px}
/* Studio toolbar */
header.toolbar{position:sticky;top:0;z-index:10;background:var(--ui-secondary);
  border-bottom:1px solid var(--ui-border);box-shadow:0 2px 18px rgba(0,0,0,.25);
  display:flex;flex-wrap:wrap;gap:12px;align-items:center;padding:10px 12px}
header.toolbar .group{display:flex;gap:10px;align-items:center;padding:8px 10px;background:var(--ui-surface);
  border:1px solid var(--ui-border);border-radius:10px}
select,input[type="file"]{background:transparent;color:var(--ui-text);border:1px solid var(--ui-border);border-radius:8px;padding:6px 8px}
input[type="checkbox"]{accent-color:var(--ui-accent)}
input[type="range"]{ -webkit-appearance:none; appearance:none; height:22px; background:transparent; width:140px;}
input[type="range"]::-webkit-slider-runnable-track{height:6px;background:linear-gradient(var(--ui-accent) 0 0) left/var(--pct,0%) 100% no-repeat, rgba(255,255,255,.14);border-radius:999px}
input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:var(--ui-accent);border:2px solid #0A0B0D;margin-top:-5px;box-shadow:0 0 0 4px var(--ui-ring)}
/* Stage */
#stage{position:relative;width:min(100vw,1080px);margin:14px auto;outline:1px solid color-mix(in oklab,var(--ui-accent) 35%,transparent);outline-offset:8px;border-radius:18px}
video{width:100%;height:auto;display:block;background:#000;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.45)}
canvas.ghost{position:absolute;inset:0;pointer-events:none;border-radius:14px}
canvas.hidden{display:none}
.overlay{position:absolute;left:12px;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px;pointer-events:none}
.bars{display:grid;gap:6px;background:rgba(0,0,0,.35);padding:10px;border-radius:10px;border:1px solid var(--ui-border)}
.bar{position:relative;height:22px;background:#222;border-radius:6px;overflow:hidden}
.fill{height:100%}
.bar span{position:absolute;left:8px;top:2px;font-weight:700;text-shadow:0 1px 2px rgba(0,0,0,.6)}
.readout{display:flex;flex-wrap:wrap;gap:14px;align-items:center;justify-content:space-between;background:rgba(0,0,0,.35);padding:10px;border-radius:10px;border:1px solid var(--ui-border)}
.tag{padding:2px 8px;border-radius:6px;font-weight:700}
.tag.pass{background:#1c6;color:#041}.tag.warn{background:#fb3;color:#201}.tag.fail{background:#e55;color:#200}
.swatch{display:inline-block;width:14px;height:14px;border-radius:3px;border:1px solid rgba(255,255,255,.35);margin-right:6px;vertical-align:-2px}
.muted{color:var(--ui-text-muted)}
/* --- Mobile fixes --- */
#studio{min-height:100dvh}
@media (max-width:900px){
  header.toolbar{position:static;overflow-x:auto;-webkit-overflow-scrolling:touch;flex-wrap:nowrap;gap:10px}
  header.toolbar .group{flex:0 0 auto}
  #stage{width:100vw;margin:0;border-radius:0;outline:none}
  video,canvas.ghost{border-radius:0}
  .overlay{left:8px;right:8px;bottom:8px}
}
@media (max-width:900px) and (orientation:landscape){
  #stage{min-height:calc(100dvh - 8px)}
}
</style>
</head>
<body>

<!-- Landing -->
<section class="hero">
  <div class="container">
    <div class="card">
      <h1>On-Set Color & Composition Metering</h1>
      <p class="lead">Live 60:30:10 COLOR BALANCE. Built for cinematographers, photographers, and designers — right in the browser.</p>
      <div class="actions">
        <button id="openStudio" class="btn">Open studio</button>
      </div>
    </div>
  </div>
</section>

<!-- Studio -->
<section id="studio" hidden>
  <header class="toolbar">
    <button id="startBtn">Start Camera</button>
    <label>Video Source<select id="device"></select></label>
    <span id="err" class="tag fail" style="display:none"></span>

    <div class="group">
      <label><input type="checkbox" id="inclNeutrals" checked> include neutrals</label>
      <span class="muted">K=<span id="kval">3</span></span>
    </div>

    <div class="group">
      <label>Ref still <input id="refUpload" type="file" accept="image/*"></label>
      <button id="grabRef">Capture Current Image</button>
      <label>mode
        <select id="overlayMode"><option value="overlay">Ghost</option><option value="wipe">Split/Wipe</option></select>
      </label>
      <label>opacity <input id="alpha" type="range" min="0" max="100" value="45"></label>
    </div>

    <div class="group">
      <label>scale <input id="scale" type="range" min="50" max="150" value="100"></label>
      <label>x <input id="offx" type="range" min="-200" max="200" value="0"></label>
      <label>y <input id="offy" type="range" min="-200" max="200" value="0"></label>
      <label><input id="flip" type="checkbox"> flip</label>
      <label><input id="grid" type="checkbox" checked> thirds/grid</label>
      <label id="wipeWrap" style="display:none">wipe <input id="wipe" type="range" min="0" max="100" value="50"></label>
    </div>

    <div class="group">
      <label><input id="phiOn" type="checkbox" checked> Golden HUD</label>
      <label>spiral
        <select id="phiSpiral">
          <option value="off" selected>off — no spiral</option>
          <option value="auto">Auto Detect</option>
          <option value="tl">TL</option><option value="tr">TR</option>
          <option value="bl">BL</option><option value="br">BR</option>
        </select>
      </label>
      <label>fit
        <select id="phiFit"><option value="inscribe" selected>fit inside</option><option value="cover">cover frame</option></select>
      </label>
      <label>Q% <input id="phiQ" type="range" min="1" max="20" value="5"></label>
      <label>sat wt <input id="satW" type="range" min="0" max="100" value="55"></label>
      <label>sat curve <input id="satG" type="range" min="50" max="140" value="85"></label>
    </div>
  </header>

  <div id="stage">
    <video id="v" playsinline autoplay muted></video>
    <canvas id="ghost" class="ghost"></canvas>
    <canvas id="c" class="hidden"></canvas>
    <div class="overlay">
      <div class="bars" id="bars"></div>
      <div class="readout">
        <div id="legend"></div>
        <div>Actual: <span id="actual"></span></div>
        <div>Score: <span id="score" class="tag">--</span></div>
        <div>Phi: <span id="phiScore" class="tag">--</span></div>
      </div>
    </div>
  </div>
</section>

<script>
/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const themeRanges = () => document.querySelectorAll('input[type="range"]');
function setRangeFill(el){ const min=+el.min||0,max=+el.max||100,val=+el.value||0; el.style.setProperty('--pct', ((val-min)/(max-min))*100 + '%'); }
themeRanges().forEach(r=>{ setRangeFill(r); r.addEventListener('input',()=>setRangeFill(r)); });

/* ===== Camera bootstrap (https or localhost) ===== */
const v=$('#v'), cv=$('#c'), gcv=$('#ghost'), gctx=gcv.getContext('2d',{willReadFrequently:true});
const devSel=$('#device'), errEl=$('#err'); let emaPct=null;
function uiError(msg){ if(!msg){errEl.style.display='none';errEl.textContent='';return;} errEl.style.display='inline-block'; errEl.textContent=msg; console.warn(msg); }
async function listDevices(){ const devs=await navigator.mediaDevices.enumerateDevices(); const vids=devs.filter(d=>d.kind==='videoinput'); devSel.innerHTML=vids.map(d=>`<option value="${d.deviceId}">${d.label||'Camera'}</option>`).join(''); if(!vids.length) uiError('No cameras found.'); }
async function start(deviceId){ try{ if(v.srcObject) v.srcObject.getTracks().forEach(t=>t.stop()); const stream=await navigator.mediaDevices.getUserMedia({video: deviceId?{deviceId:{exact:deviceId}}:true, audio:false}); v.srcObject=stream; uiError(''); }catch(e){ uiError('Failed to start camera: '+e.message); throw e; }}
async function init(){
  const isLoop = /^(localhost|127\.0\.0\.1|::1|\[::1\])$/.test(location.hostname);
  const ok = window.isSecureContext || (location.protocol==='http:' && isLoop);
  if(!ok){ uiError('Camera requires HTTPS or http://localhost'); return; }
  try{ const s=await navigator.mediaDevices.getUserMedia({video:true,audio:false}); s.getTracks().forEach(t=>t.stop()); }catch(e){ uiError('Permission/availability error: '+e.message); return; }
  await listDevices(); if(devSel.value) await start(devSel.value);
}
$('#startBtn').addEventListener('click', init);
devSel.addEventListener('change',()=>start(devSel.value));
navigator.mediaDevices?.addEventListener?.('devicechange', listDevices);

/* ===== Landing → Studio (no stray text) ===== */
$('#openStudio').addEventListener('click', async ()=>{
  $('#studio').hidden=false;
  try{ $('#studio').scrollIntoView({behavior:'smooth',block:'start'}); }catch(_){}
  try{ await init(); }catch(_){}
});

/* ===== Ghost overlay controls ===== */
const refUpload=$('#refUpload'), grabRefBtn=$('#grabRef'), overlayMode=$('#overlayMode'),
      alpha=$('#alpha'), scale=$('#scale'), offx=$('#offx'), offy=$('#offy'),
      flip=$('#flip'), grid=$('#grid'), wipe=$('#wipe'), wipeWrap=$('#wipeWrap');
let refImg=null;
refUpload.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; const url=URL.createObjectURL(f); const img=new Image(); img.onload=()=>{refImg=img;URL.revokeObjectURL(url)}; img.src=url; });
grabRefBtn.addEventListener('click', ()=>{ if(!v.videoWidth) return; const oc=document.createElement('canvas'); oc.width=v.videoWidth; oc.height=v.videoHeight; oc.getContext('2d').drawImage(v,0,0); const img=new Image(); img.onload=()=>{refImg=img}; img.src=oc.toDataURL('image/png'); });
overlayMode.addEventListener('change', ()=>{ wipeWrap.style.display = overlayMode.value==='wipe' ? 'inline-block':'none'; });

function drawGrid(ctx,W,H){
  ctx.save(); ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(W/3,0);ctx.lineTo(W/3,H); ctx.moveTo(2*W/3,0);ctx.lineTo(2*W/3,H);
  ctx.moveTo(0,H/3);ctx.lineTo(W,H/3); ctx.moveTo(0,2*H/3);ctx.lineTo(W,2*H/3); ctx.stroke();
  ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.beginPath(); ctx.moveTo(W/2,0);ctx.lineTo(W/2,H); ctx.moveTo(0,H/2);ctx.lineTo(W,H/2); ctx.stroke(); ctx.restore();
}
function drawGhost(){
  const W=gcv.width = v.clientWidth||v.videoWidth; const H=gcv.height = v.clientHeight || (v.videoHeight * (W/(v.videoWidth||W))|0);
  const ctx=gctx; ctx.clearRect(0,0,W,H);
  if(refImg && W>0 && H>0){
    const s=(+scale.value||100)/100, a=(+alpha.value||0)/100, dx=+offx.value||0, dy=+offy.value||0, doFlip=!!flip.checked;
    const rW=refImg.naturalWidth||refImg.width, rH=refImg.naturalHeight||refImg.height;
    const base=Math.min(W/rW, H/rH); const drawW=rW*base*s, drawH=rH*base*s; const x=((W-drawW)/2)+dx, y=((H-drawH)/2)+dy;
    ctx.save();
    if(overlayMode.value==='overlay'){
      ctx.globalAlpha=a;
      if(doFlip){ ctx.translate(W,0); ctx.scale(-1,1); ctx.drawImage(refImg,(W-x-drawW),y,drawW,drawH); }
      else ctx.drawImage(refImg,x,y,drawW,drawH);
      ctx.globalAlpha=1;
    }else{
      const pct=(+wipe.value||50)/100, wipeX=W*pct;
      ctx.save(); ctx.beginPath(); ctx.rect(0,0,wipeX,H); ctx.clip();
      if(doFlip){ ctx.translate(W,0); ctx.scale(-1,1); ctx.drawImage(refImg,(W-x-drawW),y,drawW,drawH); }
      else ctx.drawImage(refImg,x,y,drawW,drawH); ctx.restore();
      ctx.fillStyle='rgba(255,255,255,.65)'; ctx.fillRect(wipeX-1,0,2,H);
    }
    ctx.restore();
  }
  if(grid.checked) drawGrid(ctx, gcv.width, gcv.height);
}

/* ===== Color clustering + 60/30/10 grading (unchanged logic) ===== */
const TARGET=[60,30,10], K=3, DOWNSCALE_W=160, EMA=0.35;
const bars=$('#bars'), legend=$('#legend'), actualEl=$('#actual'), scoreEl=$('#score'), inclNeutrals=$('#inclNeutrals'); $('#kval').textContent=K;
function rgb2hsv(r,g,b){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,v=max;const d=max-min;s=max===0?0:d/max;if(max===min)h=0;else{switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break}h/=6}return[h,s,v]}
function kmeans(pixels,k=3,maxIter=8){const n=pixels.length/3;const centers=new Array(k).fill(0).map(_=>[0,0,0]);const first=Math.floor(Math.random()*n);centers[0]=[pixels[first*3],pixels[first*3+1],pixels[first*3+2]];
for(let ci=1;ci<k;ci++){let farIdx=0,farDist=-1;for(let i=0;i<n;i++){const r=pixels[i*3],g=pixels[i*3+1],b=pixels[i*3+2];let dmin=1e9;for(let j=0;j<ci;j++){const dr=r-centers[j][0],dg=g-centers[j][1],db=b-centers[j][2];const d=dr*dr+dg*dg+db*db;if(d<dmin)dmin=d} if(dmin>farDist){farDist=dmin;farIdx=i}} centers[ci]=[pixels[farIdx*3],pixels[farIdx*3+1],pixels[farIdx*3+2]]}
const assign=new Int16Array(n);for(let it=0;it<maxIter;it++){for(let i=0;i<n;i++){const r=pixels[i*3],g=pixels[i*3+1],b=pixels[i*3+2];let best=-1,bd=1e9;for(let j=0;j<k;j++){const dr=r-centers[j][0],dg=g-centers[j][1],db=b-centers[j][2];const d=dr*dr+dg*dg+db*db;if(d<bd){bd=d;best=j}}assign[i]=best}
const sum=centers.map(()=>[0,0,0,0]);for(let i=0;i<n;i++){const a=assign[i];const off=i*3;sum[a][0]+=pixels[off];sum[a][1]+=pixels[off+1];sum[a][2]+=pixels[off+2];sum[a][3]++}
for(let j=0;j<k;j++){if(sum[j][3]>0){centers[j][0]=sum[j][0]/sum[j][3];centers[j][1]=sum[j][1]/sum[j][3];centers[j][2]=sum[j][2]/sum[j][3]}}}
const counts=new Array(k).fill(0);for(let i=0;i<n;i++)counts[assign[i]]++;return{centers,counts}}
function grade6010(pcts){const a=[...pcts].sort((x,y)=>y-x).slice(0,3);const diffs=a.map((v,i)=>Math.abs(v-[60,30,10][i]));const weights=[0.5,0.35,0.15];const penalty=diffs.reduce((acc,d,i)=>acc+weights[i]*Math.min(1,d/30),0);const score=Math.max(0,100*(1-penalty));let tag='warn';if(score>=85)tag='pass';else if(score<60)tag='fail';return{score:Math.round(score),tag,actual:a.map(v=>Math.round(v))};}

/* ===== Golden ratio HUD ===== */
const phiOn=$('#phiOn'), phiSpiralSel=$('#phiSpiral'), phiQ=$('#phiQ'), phiScoreEl=$('#phiScore');
function getFrameRect(){ const W=gcv.width,H=gcv.height; const vAR=(v.videoWidth||0)/(v.videoHeight||1); if(!isFinite(vAR)||vAR<=0) return {x:0,y:0,w:W,h:H}; const boxAR=W/H; if(boxAR>vAR){const w=H*vAR,x=(W-w)/2;return{x,y:0,w,h:H}} else {const h=W/vAR,y=(H-h)/2;return{x:0,y,w:W,h}}}
function drawPhiGrid(ctx,rect){ const {x,y,w,h}=rect,phi=1.61803398875; const x1=x+w/phi,x2=x+w-w/phi,y1=y+h/phi,y2=y+h-h/phi;
  ctx.save(); ctx.strokeStyle='rgba(255,255,255,.45)'; ctx.setLineDash([8,6]); ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(x1,y);ctx.lineTo(x1,y+h); ctx.moveTo(x2,y);ctx.lineTo(x2,y+h); ctx.moveTo(x,y1);ctx.lineTo(x+w,y1); ctx.moveTo(x,y2);ctx.lineTo(x+w,y2); ctx.stroke();
  ctx.setLineDash([]); [[x1,y1],[x1,y2],[x2,y1],[x2,y2]].forEach(([px,py])=>{ctx.beginPath();ctx.arc(px,py,4,0,Math.PI*2);ctx.fillStyle='rgba(255,255,255,.9)';ctx.fill();}); ctx.restore();
}
function drawPhiSpiral(ctx,rect,corner='off',fit='inscribe'){ if(corner==='off') return; const {x:bx,y:by,w:BW,h:BH}=rect,phi=1.61803398875,frameAR=BW/BH;
  let rw,rh,rx,ry; if(fit==='cover'){ if(frameAR>=phi){rw=BW;rh=BW/phi;rx=bx;ry=by+(BH-rh)/2;} else {rh=BH;rw=BH*phi;rx=bx+(BW-rw)/2;ry=by;} }
  else { if(frameAR>=phi){rh=BH;rw=BH*phi;rx=bx+(BW-rw)/2;ry=by;} else {rw=BW;rh=BW/phi;rx=bx;ry=by+(BH-rh)/2;} }
  const use=corner==='auto'?'tr':corner;
  ctx.save(); ctx.strokeStyle='rgba(255,255,255,.55)'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
  let x=rx,y=ry,w=rw,h=rh,dir=use; for(let i=0;i<6;i++){ ctx.strokeRect(x,y,w,h); ctx.beginPath();
    if(dir==='tl'){ctx.arc(x+w,y+h,Math.min(w,h),Math.PI,1.5*Math.PI);dir='bl';}
    else if(dir==='tr'){ctx.arc(x,y+h,Math.min(w,h),1.5*Math.PI,0);dir='tl';}
    else if(dir==='br'){ctx.arc(x,y,Math.min(w,h),0,.5*Math.PI);dir='tr';}
    else if(dir==='bl'){ctx.arc(x+w,y,Math.min(w,h),.5*Math.PI,Math.PI);dir='br';}
    ctx.stroke(); if(w>=h){const nw=w/phi; if(use==='tr'||use==='br') x+=(w-nw); w=nw;} else {const nh=h/phi; if(use==='bl'||use==='br') y+=(h-nh); h=nh;}
  } ctx.restore();
}
function saliencyAndPhiScoreFromImageData(imgData,w,h){
  const d=imgData.data, Y=new Float32Array(w*h), S=new Float32Array(w*h);
  const beta=(+$('#satW').value)/100, gamma=(+$('#satG').value)/100;
  for(let i=0,p=0;i<d.length;i+=4,p++){const r=d[i],g=d[i+1],b=d[i+2]; const y=0.2126*r+0.7152*g+0.0722*b; const maxc=Math.max(r,g,b),minc=Math.min(r,g,b); const sat=maxc?(maxc-minc)/maxc:0; Y[p]=y; const satCurve=Math.pow(sat,gamma); S[p]=(1-beta)+beta*satCurve; }
  const blur=new Float32Array(w*h); for(let y=1;y<h-1;y++){for(let x=1;x<w-1;x++){let acc=0;for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) acc+=Y[(y+dy)*w+(x+dx)]; blur[y*w+x]=acc/9;}}
  const G=new Float32Array(w*h); for(let y=1;y<h-1;y++){for(let x=1;x<w-1;x++){const p=y*w+x; const gx=-Y[p-w-1]-2*Y[p-1]-Y[p+w-1]+Y[p-w+1]+2*Y[p+1]+Y[p+w+1]; const gy=-Y[p-w-1]-2*Y[p-w]-Y[p-w+1]+Y[p+w-1]+2*Y[p+w]+Y[p+w+1]; G[p]=Math.hypot(gx,gy);}}
  let maxG=1e-6,maxC=1e-6; for(let i=0;i<w*h;i++){const lc=Math.abs(Y[i]-blur[i]); if(G[i]>maxG)maxG=G[i]; if(lc>maxC)maxC=lc;}
  for(let i=0;i<w*h;i++){const lc=Math.abs(Y[i]-blur[i])/maxC; const eg=G[i]/maxG; S[i]=S[i]*(.5+.5*lc)*(.5+.5*eg);}
  const q=+phiQ.value||5, flat=Array.from(S).sort((a,b)=>b-a), thresh=flat[Math.max(0,Math.floor((q/100)*flat.length)-1)]||0;
  let sum=0,sx=0,sy=0; for(let y=0;y<h;y++) for(let x=0;x<w;x++){const p=y*w+x, wgt=S[p]>=thresh?S[p]:0; if(wgt>0){sum+=wgt;sx+=x*wgt;sy+=y*wgt;}}
  if(sum===0) return {cx:w/2,cy:h/2,score:0,bestCorner:null}; const cx=sx/sum, cy=sy/sum; const phi=1.61803398875, pts=[[w/phi,h/phi],[w/phi,h-h/phi],[w-w/phi,h/phi],[w-w/phi,h-h/phi]];
  let bestD=1e9,bestIdx=0; for(let i=0;i<4;i++){const [px,py]=pts[i]; const d2=(cx-px)*(cx-px)+(cy-py)*(cy-py); if(d2<bestD){bestD=d2;bestIdx=i;}}
  const dmin=Math.sqrt(bestD), diag=Math.hypot(w,h); const score=Math.max(0,Math.min(100,Math.round(100*(1-dmin/(0.15*diag))))); const corners=['tl','bl','tr','br']; return {cx,cy,score,bestCorner:corners[bestIdx]};
}
function drawPhiMarker(ctx,cx,cy){ ctx.save(); ctx.fillStyle='rgba(0,255,180,.9)'; ctx.strokeStyle='rgba(0,0,0,.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); }

/* ===== Loop ===== */
let lastMean=null;
function sceneCut(mean,th=12){ if(!lastMean){lastMean=mean;return false;} const d=Math.hypot(mean[0]-lastMean[0],mean[1]-lastMean[1],mean[2]-lastMean[2]); lastMean=mean; return d>th; }

function loop(){
  if(v.videoWidth===0){ requestAnimationFrame(loop); return; }
  drawGhost();

  // color analysis
  const scaleX=DOWNSCALE_W/v.videoWidth, w=DOWNSCALE_W, h=Math.round(v.videoHeight*scaleX);
  cv.width=w; cv.height=h; const ctx=cv.getContext('2d',{willReadFrequently:true}); ctx.drawImage(v,0,0,w,h);
  const imgData=ctx.getImageData(0,0,w,h), data=imgData.data;

  // mean for scene cut
  let r=0,g=0,b=0,cnt=0; for(let i=0;i<data.length;i+=4*8){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; cnt++; }
  const mean=[r/cnt,g/cnt,b/cnt]; if(sceneCut(mean)) emaPct=null;

  const step=12, buf=[]; for(let i=0;i<data.length;i+=step){ const R=data[i],G=data[i+1],B=data[i+2]; const [,sat]=rgb2hsv(R,G,B); if($('#inclNeutrals').checked || sat>=0.12) buf.push(R,G,B); }
  if(!buf.length){ requestAnimationFrame(loop); return; }
  const arr=new Float32Array(buf), {centers,counts}=kmeans(arr,K,7), total=counts.reduce((a,b)=>a+b,0)||1;
  const sw=counts.map((c,i)=>{const [R,G,B]=centers[i].map(x=>Math.max(0,Math.min(255,Math.round(x)))); return {rgb:[R,G,B],pct:100*c/total};}).sort((a,b)=>b.pct-a.pct).slice(0,3);
  const vec=sw.map(s=>s.pct); if(!emaPct) emaPct=vec; else emaPct=emaPct.map((p,i)=>p*(1-EMA)+vec[i]*EMA);

  bars.innerHTML=''; legend.innerHTML=''; const sorted=sw.map((s,i)=>({...s,pct:emaPct[i]})), totPct=sorted.reduce((a,b)=>a+b.pct,0)||1;
  sorted.forEach(s=>{ const pct=s.pct*100/totPct; const div=document.createElement('div'); div.className='bar';
    const fill=document.createElement('div'); fill.className='fill'; fill.style.width=`${pct.toFixed(2)}%`; fill.style.background=`rgb(${s.rgb[0]},${s.rgb[1]},${s.rgb[2]})`;
    const label=document.createElement('span'); const hex='#'+s.rgb.map(v=>v.toString(16).padStart(2,'0')).join('').toUpperCase(); label.textContent=`${pct.toFixed(1)}%  ${hex}`;
    div.appendChild(fill); div.appendChild(label); bars.appendChild(div);
    const swEl=document.createElement('span'); swEl.className='swatch'; swEl.style.background=`rgb(${s.rgb[0]},${s.rgb[1]},${s.rgb[2]})`; legend.appendChild(swEl);
  });
  const pcts=sorted.map(s=>s.pct*100/totPct), {score,tag,actual}=grade6010(pcts); $('#actual').textContent=`${actual[0]} / ${actual[1]} / ${actual[2]}`; scoreEl.textContent=score; scoreEl.className='tag '+tag;

  // φ HUD
  if($('#phiOn').checked){
    const rect=getFrameRect(); drawPhiGrid(gctx,rect);
    const {cx,cy,score:phiScore,bestCorner}=saliencyAndPhiScoreFromImageData(imgData,w,h);
    const sx=rect.x+(cx/w)*rect.w, sy=rect.y+(cy/h)*rect.h; drawPhiMarker(gctx,sx,sy);
    const mode=$('#phiSpiral').value, fit=$('#phiFit').value, spiralCorner=mode==='auto'?(bestCorner||'tr'):mode;
    if(mode!=='off') drawPhiSpiral(gctx,rect,spiralCorner,fit);
    phiScoreEl.textContent=phiScore; phiScoreEl.className='tag '+(phiScore>=85?'pass':phiScore<60?'fail':'warn');
  } else { phiScoreEl.textContent='--'; phiScoreEl.className='tag'; }

  ('requestVideoFrameCallback' in HTMLVideoElement.prototype) ? v.requestVideoFrameCallback(()=>loop()) : requestAnimationFrame(loop);
}
v.addEventListener('loadeddata', loop);
</script>
</body>
</html>


