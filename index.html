<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>60/30/10 Monitor • Ghost Overlay • Golden HUD</title>

<style>
  :root{
    --ui-primary:#0B1220; --ui-secondary:#172036; --ui-accent:#F59E0B;
    --ui-text:#EDEFF2; --ui-text-muted:#B8C2D6;
    --ui-border:rgba(255,255,255,0.08); --ui-surface:rgba(255,255,255,0.05);
    --ui-ring:rgba(245,158,11,0.55);
  }

  /* base */
  *{ box-sizing:border-box } html,body{ height:100% }
  body{ margin:0; font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
        background:var(--ui-primary); color:var(--ui-text); -webkit-font-smoothing:antialiased }
  body.lock{ overflow:hidden } /* just CSS here, no JS */

  .btn{ appearance:none; border:none; border-radius:10px; padding:10px 14px; font-weight:700;
        background:var(--ui-accent); color:#0A0B0D; box-shadow:0 2px 10px rgba(0,0,0,.25);
        transition:transform .08s ease, filter .12s ease }
  .btn:hover{ filter:brightness(1.05) } .btn:active{ transform:translateY(1px) }

  /* landing */
  .hero{
    min-height:100dvh; display:grid; place-items:center; padding:24px;
    background: radial-gradient(60% 60% at 70% 10%,
                color-mix(in oklab, var(--ui-accent) 14%, transparent), transparent 60%),
                var(--ui-primary);
  }
  #landing{ transition:opacity .25s ease, transform .25s ease }
  #landing.is-hiding{ opacity:0; transform:translateY(-8px) }
  #landing[hidden]{ display:none!important }

  /* Card with background image */
  .hero .card{
    position:relative; overflow:hidden; padding:0;
    width:min(900px,96vw); border-radius:16px;
    background:var(--ui-secondary); border:1px solid var(--ui-border);
    box-shadow:0 24px 80px rgba(0,0,0,.45);
  }
  .card .bg{
    position:absolute; inset:0;
    background:var(--hero, url('soLUTion1a.png')) center/cover no-repeat;
    filter:saturate(110%) contrast(1.05) brightness(.85);
    transform:scale(1.02);
  }
  .card .scrim{ position:absolute; inset:0;
    background:linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.55)) }
  .card .content{ position:relative; z-index:1; padding:28px; display:grid; gap:12px }
  .hero h1{ margin:0 0 6px; font-size:28px }
  .hero p{ margin:8px 0 18px; color:var(--ui-text-muted) }
  .hero .actions{ display:flex; gap:12px; flex-wrap:wrap }

  /* studio */
  #studio{ min-height:100dvh; padding:10px 10px 24px }
  #studio[hidden]{ display:none!important }
  header.toolbar{
    position:sticky; top:0; z-index:10; display:flex; flex-wrap:wrap; gap:12px; align-items:center;
    padding:10px 12px; background:var(--ui-secondary);
    border-bottom:1px solid var(--ui-border); box-shadow:0 2px 18px rgba(0,0,0,.25);
  }
  .group{ display:flex; gap:10px; align-items:center; padding:8px 10px;
          background:var(--ui-surface); border:1px solid var(--ui-border);
          border-radius:10px; backdrop-filter:saturate(120%) blur(2px) }

  #stage{ position:relative; width:min(100vw,1080px); margin:14px auto;
          outline:1px solid color-mix(in oklab, var(--ui-accent) 35%, transparent); outline-offset:8px; border-radius:18px }
  video{ width:100%; height:auto; display:block; background:#000; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.45) }
  canvas.overlay{ position:absolute; inset:0; pointer-events:none; border-radius:14px }
  canvas.hidden{ display:none }

  .overlayHUD{ position:absolute; left:12px; right:12px; bottom:12px; display:flex; flex-direction:column; gap:8px; pointer-events:none }
  .bars{ display:grid; gap:6px; background:rgba(0,0,0,.35); padding:10px; border-radius:10px; border:1px solid var(--ui-border) }
  .bar{ position:relative; height:22px; background:#222; border-radius:6px; overflow:hidden }
  .fill{ height:100% }
  .bar span{ position:absolute; left:8px; top:2px; font-weight:600; text-shadow:0 1px 2px rgba(0,0,0,.6) }
  .bar .target{ position:absolute; top:3px; bottom:3px; width:3px; background:var(--ui-accent); border-radius:2px; box-shadow:0 0 0 1px rgba(0,0,0,.35), 0 0 6px rgba(0,0,0,.25); transform:translateX(-50%); pointer-events:none }
  .readout{ display:flex; flex-wrap:wrap; gap:14px; align-items:center; justify-content:space-between;
            background:rgba(0,0,0,.35); padding:10px; border-radius:10px; border:1px solid var(--ui-border) }
  .swatch{ display:inline-block; width:14px; height:14px; border-radius:3px; border:1px solid rgba(255,255,255,.35); margin-right:6px; vertical-align:-2px }
  .tag{ padding:2px 8px; border-radius:6px; font-weight:700; color:#041 }
  .tag.pass{ background:#1c6 } .tag.warn{ background:#fb3; color:#201 } .tag.fail{ background:#e55; color:#200 }
  #err{ color:#ff8c8c; font-weight:600 }

  /* mobile */
  @media (max-width:900px){
    header.toolbar{ position:static; overflow-x:auto; -webkit-overflow-scrolling:touch; flex-wrap:nowrap; gap:10px }
    header.toolbar .group{ flex:0 0 auto }
    #stage{ width:100vw; margin:0; border-radius:0; outline:none }
    video, canvas.overlay{ border-radius:0 }
    .overlayHUD{ left:8px; right:8px; bottom:8px }
  }
  @media (max-width:900px) and (orientation:landscape){
    #stage{ min-height:calc(100dvh - 8px) }
  }
</style>

<body>

<section id="landing" class="hero">
  <div class="card" style="--hero:url('./SoLUTion-v0.1/soLUTion1a.png')">
    <div class="bg"></div>
    <div class="scrim"></div>
    <div class="content">
      <h1>On-Set Color &amp; Composition Studio</h1>
      <p>Live 60/30/10 color balance. Reference ghost/wipe. Golden-ratio grid &amp; focal dot.</p>
      <div class="actions">
        <button id="openStudio" class="btn">Open studio</button>
      </div>
      <p class="small" style="opacity:.85">Camera requires HTTPS or <code>http://localhost</code>. Mobile supported.</p>
    </div>
  </div>
</section>

<main id="studio" hidden>
  <header class="toolbar">
    <button id="startBtn" class="btn">Start camera</button>
    <label>Camera <select id="device"></select></label>
    <span id="err"></span>

    <div class="group">
      <label><input type="checkbox" id="inclNeutrals" checked> include neutrals</label>
      <label class="muted">K=<span id="kval">3</span></label>
    </div>

    <div class="group">
      <label>Ref still <input id="refUpload" type="file" accept="image/*"></label>
      <button id="grabRef" class="btn">Capture current</button>
      <label>mode
        <select id="overlayMode">
          <option value="overlay">Ghost</option>
          <option value="wipe">Split/Wipe</option>
        </select>
      </label>
      <label>opacity <input id="alpha" type="range" min="0" max="100" value="45"></label>
    </div>

    <div class="group"><button id="btnCapture" class="btn">Capture photo</button></div>

    <div class="group">
      <label>scale <input id="scale" type="range" min="50" max="150" value="100"></label>
      <label>x <input id="offx" type="range" min="-200" max="200" value="0"></label>
      <label>y <input id="offy" type="range" min="-200" max="200" value="0"></label>
      <label class="muted"><input id="flip" type="checkbox"> flip</label>
      <label class="muted"><input id="grid" type="checkbox"> grid</label>
      <label class="muted" id="wipeWrap" style="display:none">wipe <input id="wipe" type="range" min="0" max="100" value="50"></label>
    </div>

    <div class="group">
      <label><input id="phiOn" type="checkbox"> Golden HUD</label>
      <label>spiral
        <select id="phiSpiral">
          <option value="off" selected>off — no spiral</option>
          <option value="auto">Auto Detect</option>
          <option value="tl">TL</option><option value="tr">TR</option>
          <option value="bl">BL</option><option value="br">BR</option>
        </select>
      </label>
      <label>fit
        <select id="phiFit">
          <option value="inscribe" selected>fit inside</option>
          <option value="cover">cover frame</option>
        </select>
      </label>
      <label>Q% <input id="phiQ" type="range" min="1" max="20" value="5"></label>
      <label>sat wt <input id="satW" type="range" min="0" max="100" value="55"></label>
      <label>sat curve <input id="satG" type="range" min="50" max="140" value="85"></label>
    </div>
  </header>

  <section id="stage">
    <video id="v" playsinline autoplay muted></video>
    <canvas id="ghost" class="overlay"></canvas>
    <canvas id="c" class="hidden"></canvas>

    <div class="overlayHUD">
      <div class="bars" id="bars"></div>
      <div class="readout">
        <div id="legend"></div>
        <div>Actual: <span id="actual"></span></div>
        <div>Score: <span id="score" class="tag">--</span></div>
        <div>Phi: <span id="phiScore" class="tag">--</span></div>
      </div>
    </div>
  </section>
</main>

<div id="paywall" hidden>
  <div class="pw-card">
    <h2>Unlock Studio</h2>
    <p id="pw-msg">Start your free 3-day trial. <span id="pw-countdown"></span></p>
    <div class="pw-actions">
      <button class="btn" id="btn-month">Go Pro — $0.99/mo</button>
      <button class="btn" id="btn-year">$9.99/yr</button>
      <button class="btn" id="btn-life">Lifetime $29.99</button>
    </div>
    <div class="pw-subtle">
      <button class="link" id="btn-start-trial">Start free trial</button>
      <button class="link" id="btn-restore">I already purchased</button>
    </div>
  </div>
</div>

<script>
/* ===== helpers ===== */
const $ = sel => document.querySelector(sel);

/* ===== scroll lock on landing ===== */
document.addEventListener('DOMContentLoaded', ()=>{ document.body.classList.add('lock'); });

/* ===== capture & save ===== */
async function captureFrameToBlob(includeOverlay = true){
  const W = gcv.width || v.clientWidth || v.videoWidth || 1280;
  const H = gcv.height || v.clientHeight || v.videoHeight || 720;
  const oc = document.createElement('canvas'); oc.width=W; oc.height=H;
  const octx = oc.getContext('2d');
  octx.fillStyle='#000'; octx.fillRect(0,0,W,H);
  const rect = (typeof getFrameRect==='function') ? getFrameRect() : {x:0,y:0,w:W,h:H};
  try{ octx.drawImage(v, rect.x, rect.y, rect.w, rect.h); }catch(_){}
  if (includeOverlay && gcv) octx.drawImage(gcv,0,0,W,H);
  return await new Promise(res=>oc.toBlob(res,'image/jpeg',0.92));
}
async function saveCapture(){
  try{
    await new Promise(r=>requestAnimationFrame(r));
    const blob = await captureFrameToBlob(true); if(!blob) return;
    const filename = `6010-capture-${new Date().toISOString().replace(/[:.]/g,'-')}.jpg`;
    const file = new File([blob], filename, { type:'image/jpeg' });
    if (navigator.canShare?.({ files:[file] })) { await navigator.share({ files:[file], title:'60/30/10 capture' }); return; }
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=filename; a.style.display='none';
    document.body.appendChild(a); a.click();
    if (/iPad|iPhone|iPod/.test(navigator.userAgent)) setTimeout(()=>window.open(url,'_blank'),350);
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },2000);
  }catch(e){ console.warn(e); alert('Could not save the photo.'); }
}
document.getElementById('btnCapture')?.addEventListener('click', saveCapture);

/* ===== theme (kept) ===== */
function updRange(el){ const min=+el.min||0, max=+el.max||100, val=+el.value||0; el.style.setProperty('--pct', (((val-min)/(max-min))*100)+'%'); }
function applyTheme(name){
  document.body.classList.remove('theme-magenta-cosmos','theme-cyan-sunrise');
  if (name==='magenta-cosmos') document.body.classList.add('theme-magenta-cosmos');
  if (name==='cyan-sunrise')   document.body.classList.add('theme-cyan-sunrise');
  localStorage.setItem('uiTheme6010', name);
  document.querySelectorAll('input[type="range"]').forEach(updRange);
}
applyTheme(localStorage.getItem('uiTheme6010')||'teal-mango');
document.querySelectorAll('input[type="range"]').forEach(el=>{ updRange(el); el.addEventListener('input', ()=>updRange(el)); });

/* ===== soft paywall ===== */
const TRIAL_DAYS=3, TRIAL_KEY='trialStartedAt_v1', PRO_KEY='proEntitlement_v1';
function getMsLeft(){ const started=+localStorage.getItem(TRIAL_KEY); if(!started) return -1; return (started+TRIAL_DAYS*86400000)-Date.now(); }
function fmtCountdown(ms){ if(ms<=0) return 'trial ended'; const d=Math.floor(ms/86400000), h=Math.floor(ms%86400000/3600000), m=Math.floor(ms%3600000/60000); return `${d}d ${h}h ${m}m left`; }
function hasPro(){ return !!localStorage.getItem(PRO_KEY); }
function showPaywall(msg){ const pw=$('#paywall'), msgEl=$('#pw-msg'), cdEl=$('#pw-countdown'); msgEl.firstChild.nodeValue=(msg||'You’re on a free 3-day trial. '); const upd=()=>{ const ms=getMsLeft(); cdEl.textContent=ms>0?fmtCountdown(ms):'trial ended'; }; upd(); clearInterval(showPaywall._t); showPaywall._t=setInterval(upd,15000); pw.hidden=false; }
function hidePaywall(){ const pw=$('#paywall'); pw.hidden=true; if(showPaywall._t) clearInterval(showPaywall._t); }
async function ensureEntitled(){
  if (hasPro()) return true;
  const ms=getMsLeft();
  if (ms===-1){ showPaywall('Start your free 3-day trial. '); return false; }
  if (ms>0){ hidePaywall(); return true; }
  showPaywall('Your trial ended. '); return false;
}
$('#btn-start-trial')?.addEventListener('click', ()=>{ if(!localStorage.getItem(TRIAL_KEY)) localStorage.setItem(TRIAL_KEY, Date.now().toString()); hidePaywall(); });
$('#btn-month')?.addEventListener('click', ()=>window.open('https://example.com/monthly','_blank'));
$('#btn-year') ?.addEventListener('click', ()=>window.open('https://example.com/yearly','_blank'));
$('#btn-life') ?.addEventListener('click', ()=>window.open('https://example.com/lifetime','_blank'));
$('#btn-restore')?.addEventListener('click', ()=>{ const key=prompt('Paste your license / token:'); if(key){ localStorage.setItem(PRO_KEY,key); hidePaywall(); }});

/* ===== landing → studio ===== */
$('#openStudio').addEventListener('click', async ()=>{
  if (!(await ensureEntitled())) return;
  document.body.classList.remove('lock');         // unlock scroll
  const landing=$('#landing'), studio=$('#studio');
  studio.hidden=false;
  try{ await init(); }catch(_){}
  landing.classList.add('is-hiding');
  landing.addEventListener('transitionend', ()=>landing.hidden=true,{once:true});
  try{ studio.scrollIntoView({behavior:'smooth', block:'start'}); }catch(_){}
});

/* ===== camera & devices / analysis / overlays ===== */
/* (unchanged from your version — left intact for brevity) */
const TARGET=[60,30,10], K=3, DOWNSCALE_W=160, EMA=0.35;
const v=$('#v'), cv=$('#c'), bars=$('#bars');
const legend=$('#legend'), actualEl=$('#actual'), scoreEl=$('#score');
const devSel=$('#device'), inclNeutrals=$('#inclNeutrals'), errEl=$('#err'); $('#kval').textContent=K;
let emaPct=null;
function uiError(msg){ errEl.textContent=msg||''; if(msg) console.warn(msg); }
async function listDevices(){ const devs=await navigator.mediaDevices.enumerateDevices(); const vids=devs.filter(d=>d.kind==='videoinput'); devSel.innerHTML=vids.map(d=>`<option value="${d.deviceId}">${d.label||'Camera'}</option>`).join(''); if(!vids.length) uiError('No cameras found. Start DroidCam/OBS or plug in capture.'); }
async function start(deviceId){ try{ if(v.srcObject) v.srcObject.getTracks().forEach(t=>t.stop()); const stream=await navigator.mediaDevices.getUserMedia({video: deviceId?{deviceId:{exact:deviceId}}:true,audio:false}); v.srcObject=stream; uiError(''); }catch(e){ uiError('Failed to start camera: '+e.message); throw e; } }
async function init(){ const isLoopback=/^(localhost|127\.0\.0\.1|::1|\[::1\])$/.test(location.hostname); const allowed=window.isSecureContext||(location.protocol==='http:'&&isLoopback); if(!allowed){ uiError('Camera requires HTTPS or http://localhost'); return; } try{ const s=await navigator.mediaDevices.getUserMedia({video:true,audio:false}); s.getTracks().forEach(t=>t.stop()); }catch(e){ uiError('Permission/availability error: '+e.message); return; } await listDevices(); if(devSel.value) await start(devSel.value); }
$('#startBtn').onclick=init; devSel.addEventListener('change',()=>start(devSel.value)); inclNeutrals.addEventListener('change',()=>{emaPct=null;}); navigator.mediaDevices?.addEventListener?.('devicechange', listDevices);
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h=0,s,v=max,d=max-min; s=max===0?0:d/max; if(max!==min){ switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break} h/=6 } return [h,s,v]; }
function kmeans(pixels,k=3,maxIter=8){ const n=pixels.length/3; const centers=new Array(k).fill(0).map(()=>[0,0,0]); const first=Math.floor(Math.random()*n); centers[0]=[pixels[first*3],pixels[first*3+1],pixels[first*3+2]]; for(let ci=1;ci<k;ci++){ let farIdx=0,farDist=-1; for(let i=0;i<n;i++){ const r=pixels[i*3],g=pixels[i*3+1],b=pixels[i*3+2]; let dmin=Infinity; for(let j=0;j<ci;j++){ const dr=r-centers[j][0],dg=g-centers[j][1],db=b-centers[j][2]; const d=dr*dr+dg*dg+db*db; if(d<dmin) dmin=d; } if(dmin>farDist){ farDist=dmin; farIdx=i; } } centers[ci]=[pixels[farIdx*3],pixels[farIdx*3+1],pixels[farIdx*3+2]]; } const assign=new Int16Array(n); for(let it=0;it<maxIter;it++){ for(let i=0;i<n;i++){ const r=pixels[i*3],g=pixels[i*3+1],b=pixels[i*3+2]; let best=-1,bd=Infinity; for(let j=0;j<k;j++){ const dr=r-centers[j][0],dg=g-centers[j][1],db=b-centers[j][2]; const d=dr*dr+dg*dg+db*db; if(d<bd){ bd=d; best=j; } } assign[i]=best; } const sum=centers.map(()=>[0,0,0,0]); for(let i=0;i<n;i++){ const a=assign[i],off=i*3; sum[a][0]+=pixels[off]; sum[a][1]+=pixels[off+1]; sum[a][2]+=pixels[off+2]; sum[a][3]++; } for(let j=0;j<k;j++){ if(sum[j][3]>0){ centers[j][0]=sum[j][0]/sum[j][3]; centers[j][1]=sum[j][1]/sum[j][3]; centers[j][2]=sum[j][2]/sum[j][3]; } } } const counts=new Array(k).fill(0); for(let i=0;i<n;i++) counts[assign[i]]++; return {centers,counts}; }
function grade6010(pcts){ const a=[...pcts].sort((x,y)=>y-x).slice(0,3); const diffs=a.map((v,i)=>Math.abs(v-[60,30,10][i])); const weights=[0.5,0.35,0.15]; const penalty=diffs.reduce((acc,d,i)=>acc+weights[i]*Math.min(1,d/30),0); const score=Math.max(0,100*(1-penalty)); let tag='warn'; if(score>=85) tag='pass'; else if(score<60) tag='fail'; return {score:Math.round(score), tag, actual:a.map(v=>Math.round(v))}; }
const gcv=$('#ghost'), gctx=gcv.getContext('2d',{willReadFrequently:true});
const refUpload=$('#refUpload'), grabRefBtn=$('#grabRef'), overlayMode=$('#overlayMode');
const alpha=$('#alpha'), scale=$('#scale'), offx=$('#offx'), offy=$('#offy');
const flip=$('#flip'), grid=$('#grid'), wipe=$('#wipe'), wipeWrap=$('#wipeWrap');
let refImg=null;
refUpload.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; const url=URL.createObjectURL(f); const img=new Image(); img.onload=()=>{ refImg=img; URL.revokeObjectURL(url); }; img.src=url; });
grabRefBtn.addEventListener('click', ()=>{ if(v.videoWidth===0) return; const oc=document.createElement('canvas'); oc.width=v.videoWidth; oc.height=v.videoHeight; oc.getContext('2d').drawImage(v,0,0); const img=new Image(); img.onload=()=>{ refImg=img; }; img.src=oc.toDataURL('image/png'); });
overlayMode.addEventListener('change', ()=>{ wipeWrap.style.display = overlayMode.value==='wipe' ? 'inline-block' : 'none'; });
function drawGrid(ctx,W,H){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(W/3,0); ctx.lineTo(W/3,H); ctx.moveTo(2*W/3,0); ctx.lineTo(2*W/3,H); ctx.moveTo(0,H/3); ctx.lineTo(W,H/3); ctx.moveTo(0,2*H/3); ctx.lineTo(W,2*H/3); ctx.stroke(); ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke(); ctx.restore(); }
function drawGhost(){ const W=gcv.width=v.clientWidth||v.videoWidth; const H=gcv.height=v.clientHeight||(v.videoHeight*(W/(v.videoWidth||W))|0); const ctx=gctx; ctx.clearRect(0,0,W,H); if(refImg&&W>0&&H>0){ const s=(+scale.value||100)/100, a=(+alpha.value||0)/100, dx=+offx.value||0, dy=+offy.value||0, doFlip=!!flip.checked; const rW=refImg.naturalWidth||refImg.width, rH=refImg.naturalHeight||refImg.height; const base=Math.min(W/rW,H/rH), drawW=rW*base*s, drawH=rH*base*s, x=((W-drawW)/2)+dx, y=((H-drawH)/2)+dy; ctx.save(); if(overlayMode.value==='overlay'){ ctx.globalAlpha=a; if(doFlip){ ctx.translate(W,0); ctx.scale(-1,1); ctx.drawImage(refImg,(W-x-drawW),y,drawW,drawH); } else ctx.drawImage(refImg,x,y,drawW,drawH); ctx.globalAlpha=1; } else { const pct=(+wipe.value||50)/100, wipeX=W*pct; ctx.save(); ctx.beginPath(); ctx.rect(0,0,wipeX,H); ctx.clip(); if(doFlip){ ctx.translate(W,0); ctx.scale(-1,1); ctx.drawImage(refImg,(W-x-drawW),y,drawW,drawH); } else ctx.drawImage(refImg,x,y,drawW,drawH); ctx.restore(); ctx.fillStyle='rgba(255,255,255,0.65)'; ctx.fillRect(wipeX-1,0,2,H); } ctx.restore(); } if(grid.checked) drawGrid(ctx,gcv.width,gcv.height); }
window.addEventListener('keydown', e=>{ const step=e.shiftKey?10:2; if(e.key==='ArrowLeft'){ offx.value=(+offx.value||0)-step; e.preventDefault(); } if(e.key==='ArrowRight'){ offx.value=(+offx.value||0)+step; e.preventDefault(); } if(e.key==='ArrowUp'){ offy.value=(+offy.value||0)-step; e.preventDefault(); } if(e.key==='ArrowDown'){ offy.value=(+offy.value||0)+step; e.preventDefault(); } if(e.key==='['){ alpha.value=Math.max(0,(+alpha.value||0)-2); } if(e.key===']'){ alpha.value=Math.min(100,(+alpha.value||0)+2); } });

/* Golden HUD */
const phiOn=$('#phiOn'), phiSpiralSel=$('#phiSpiral'), phiQ=$('#phiQ'), phiScoreEl=$('#phiScore');
function getFrameRect(){ const W=gcv.width,H=gcv.height, vAR=(v.videoWidth||0)/(v.videoHeight||1); if(!isFinite(vAR)||vAR<=0) return {x:0,y:0,w:W,h:H}; const boxAR=W/H; if(boxAR>vAR){ const w=H*vAR,x=(W-w)/2; return {x,y:0,w,h:H}; } else { const h=W/vAR,y=(H-h)/2; return {x:0,y,w:W,h}; } }
function drawPhiGrid(ctx,rect){ const {x,y,w,h}=rect, phi=1.61803398875; const x1=x+w/phi, x2=x+w-w/phi, y1=y+h/phi, y2=y+h-h/phi; ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.45)'; ctx.setLineDash([8,6]); ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(x1,y); ctx.lineTo(x1,y+h); ctx.moveTo(x2,y); ctx.lineTo(x2,y+h); ctx.moveTo(x,y1); ctx.lineTo(x+w,y1); ctx.moveTo(x,y2); ctx.lineTo(x+w,y2); ctx.stroke(); ctx.setLineDash([]); [[x1,y1],[x1,y2],[x2,y1],[x2,y2]].forEach(([px,py])=>{ ctx.beginPath(); ctx.arc(px,py,4,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fill(); }); ctx.restore(); }
function drawPhiSpiral(ctx,rect,corner='auto',fit='inscribe'){ if(corner==='off') return; const {x:bx,y:by,w:BW,h:BH}=rect, phi=1.61803398875, frameAR=BW/BH; let rw,rh,rx,ry; if(fit==='cover'){ if(frameAR>=phi){ rw=BW; rh=BW/phi; rx=bx; ry=by+(BH-rh)/2; } else { rh=BH; rw=BH*phi; rx=bx+(BW-rw)/2; ry=by; } } else { if(frameAR>=phi){ rh=BH; rw=BH*phi; rx=bx+(BW-rw)/2; ry=by; } else { rw=BW; rh=BW/phi; rx=bx; ry=by+(BH-rh)/2; } } const use=corner==='auto'?'tr':corner; ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.55)'; ctx.lineWidth=2; ctx.setLineDash([6,6]); let x=rx,y=ry,w=rw,h=rh,dir=use; for(let i=0;i<6;i++){ ctx.strokeRect(x,y,w,h); ctx.beginPath(); if(dir==='tl'){ ctx.arc(x+w,y+h,Math.min(w,h),Math.PI,1.5*Math.PI); dir='bl'; } else if(dir==='tr'){ ctx.arc(x,y+h,Math.min(w,h),1.5*Math.PI,0); dir='tl'; } else if(dir==='br'){ ctx.arc(x,y,Math.min(w,h),0,0.5*Math.PI); dir='tr'; } else if(dir==='bl'){ ctx.arc(x+w,y,Math.min(w,h),0.5*Math.PI,Math.PI); dir='br'; } ctx.stroke(); if(w>=h){ const nw=w/phi; if(use==='tr'||use==='br') x+=(w-nw); w=nw; } else { const nh=h/phi; if(use==='bl'||use==='br') y+=(h-nh); h=nh; } } ctx.restore(); }
function saliencyFromImageData(imgData,w,h){ const d=imgData.data, Y=new Float32Array(w*h), S=new Float32Array(w*h); const beta=(+($('#satW')?.value)||0)/100, gamma=(+($('#satG')?.value)||100)/100; for(let i=0,p=0;i<d.length;i+=4,p++){ const r=d[i],g=d[i+1],b=d[i+2], y=0.2126*r+0.7152*g+0.0722*b; const maxc=Math.max(r,g,b), minc=Math.min(r,g,b), sat=maxc?(maxc-minc)/maxc:0; Y[p]=y; const satCurve=Math.pow(sat,gamma); S[p]=(1-beta)+beta*satCurve; } const blur=new Float32Array(w*h); for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){ let acc=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) acc+=Y[(y+dy)*w+(x+dx)]; blur[y*w+x]=acc/9; } const G=new Float32Array(w*h); for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){ const p=y*w+x; const gx=-Y[p-w-1]-2*Y[p-1]-Y[p+w-1]+Y[p-w+1]+2*Y[p+1]+Y[p+w+1]; const gy=-Y[p-w-1]-2*Y[p-w]-Y[p-w+1]+Y[p+w-1]+2*Y[p+w]+Y[p+w+1]; G[p]=Math.hypot(gx,gy); } let maxG=1e-6,maxC=1e-6; for(let i=0;i<w*h;i++){ const lc=Math.abs(Y[i]-blur[i]); if(G[i]>maxG)maxG=G[i]; if(lc>maxC)maxC=lc; } for(let i=0;i<w*h;i++){ const lc=Math.abs(Y[i]-blur[i])/maxC, eg=G[i]/maxG; S[i]=S[i]*(0.5+0.5*lc)*(0.5+0.5*eg); } const q=+($('#phiQ').value)||5, flat=Array.from(S).sort((a,b)=>b-a), thresh=flat[Math.max(0,Math.floor((q/100)*flat.length)-1)]||0; let sum=0,sx=0,sy=0; for(let y=0;y<h;y++) for(let x=0;x<w;x++){ const p=y*w+x, wgt=S[p]>=thresh?S[p]:0; if(wgt>0){ sum+=wgt; sx+=x*wgt; sy+=y*wgt; } } if(sum===0) return { cx:w/2, cy:h/2, score:0, bestCorner:null }; const cx=sx/sum, cy=sy/sum, phi=1.61803398875, pts=[[w/phi,h/phi],[w/phi,h-h/phi],[w-w/phi,h/phi],[w-w/phi,h-h/phi]]; let bestD=1e9,bestIdx=0; for(let i=0;i<4;i++){ const [px,py]=pts[i], d2=(cx-px)*(cx-px)+(cy-py)*(cy-py); if(d2<bestD){ bestD=d2; bestIdx=i; } } const dmin=Math.sqrt(bestD), diag=Math.hypot(w,h), score=Math.max(0,Math.min(100,Math.round(100*(1-dmin/(0.15*diag))))); return { cx, cy, score, bestCorner:['tl','bl','tr','br'][bestIdx] }; }
function drawPhiMarker(ctx,cx,cy){ ctx.save(); ctx.fillStyle='rgba(0,255,180,0.9)'; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); }

let lastMean=null;
function sceneCut(mean,th=12){ if(!lastMean){ lastMean=mean; return false; } const d=Math.hypot(mean[0]-lastMean[0],mean[1]-lastMean[1],mean[2]-lastMean[2]); lastMean=mean; return d>th; }

function loop(){
  if (v.videoWidth===0){ requestAnimationFrame(loop); return; }
  drawGhost();
  const scaleX=DOWNSCALE_W/ v.videoWidth;
  const w=DOWNSCALE_W, h=Math.round(v.videoHeight*scaleX);
  cv.width=w; cv.height=h;
  const ctx=cv.getContext('2d',{willReadFrequently:true});
  ctx.drawImage(v,0,0,w,h);
  const imgData=ctx.getImageData(0,0,w,h);
  const data=imgData.data;

  let r=0,g=0,b=0,cnt=0; for(let i=0;i<data.length;i+=32){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; cnt++; }
  const mean=[r/cnt,g/cnt,b/cnt]; if(sceneCut(mean)) emaPct=null;

  const step=12, buf=[];
  for(let i=0;i<data.length;i+=step){
    const R=data[i],G=data[i+1],B=data[i+2]; const [,sat]=rgb2hsv(R,G,B);
    if (inclNeutrals.checked || sat>=0.12) buf.push(R,G,B);
  }
  if(!buf.length){ requestAnimationFrame(loop); return; }

  const arr=new Float32Array(buf);
  const {centers,counts}=kmeans(arr,K,7);
  const total=counts.reduce((a,b)=>a+b,0)||1;
  const sw=counts.map((c,i)=>{ const [R,G,B]=centers[i].map(x=>Math.max(0,Math.min(255,Math.round(x)))); return { rgb:[R,G,B], pct:100*c/total }; }).sort((a,b)=>b.pct-a.pct).slice(0,3);
  const vec=sw.map(s=>s.pct); if(!emaPct) emaPct=vec; else emaPct=emaPct.map((p,i)=>p*(1-EMA)+vec[i]*EMA);

  bars.innerHTML=''; legend.innerHTML='';
  const sorted=sw.map((s,i)=>({...s, pct:emaPct[i]}));
  const totPct=sorted.reduce((a,b)=>a+b.pct,0)||1;

  sorted.forEach((s,i)=>{
    const pct=s.pct*100/totPct;
    const div=document.createElement('div'); div.className='bar';
    const fill=document.createElement('div'); fill.className='fill'; fill.style.width=`${pct.toFixed(2)}%`; fill.style.background=`rgb(${s.rgb[0]},${s.rgb[1]},${s.rgb[2]})`;
    const label=document.createElement('span'); const hex='#'+s.rgb.map(v=>v.toString(16).padStart(2,'0')).join('').toUpperCase(); label.textContent=`${pct.toFixed(1)}%  ${hex}`;
    const tick=document.createElement('i'); tick.className='target'; tick.style.left=`${TARGET[i]}%`;
    div.appendChild(fill); div.appendChild(label); div.appendChild(tick); bars.appendChild(div);
    const swEl=document.createElement('span'); swEl.className='swatch'; swEl.style.background=`rgb(${s.rgb[0]},${s.rgb[1]},${s.rgb[2]})`; legend.appendChild(swEl);
  });

  const pcts=sorted.map(s=>s.pct*100/totPct);
  const {score,tag,actual}=grade6010(pcts);
  actualEl.textContent=`${actual[0]} / ${actual[1]} / ${actual[2]}`;
  scoreEl.textContent=score; scoreEl.className=`tag ${tag}`;

  if (phiOn.checked){
    const rect=getFrameRect();
    drawPhiGrid(gctx,rect);
    const {cx,cy,score:phiScore,bestCorner}=saliencyFromImageData(imgData,w,h);
    const sx=rect.x+(cx/w)*rect.w, sy=rect.y+(cy/h)*rect.h;
    drawPhiMarker(gctx,sx,sy);
    const mode=phiSpiralSel.value, fit=$('#phiFit').value;
    const corner=mode==='auto'?(bestCorner||'tr'):mode;
    if (mode!=='off') drawPhiSpiral(gctx,rect,corner,fit);
    phiScoreEl.textContent=phiScore;
    phiScoreEl.className='tag '+(phiScore>=85?'pass':phiScore<60?'fail':'warn');
  }else{
    phiScoreEl.textContent='--'; phiScoreEl.className='tag';
  }

  ('requestVideoFrameCallback' in HTMLVideoElement.prototype)
    ? v.requestVideoFrameCallback(()=>loop())
    : requestAnimationFrame(loop);
}
v.addEventListener('loadeddata', loop);
</script>

</body>
</html>

